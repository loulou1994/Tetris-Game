{"version":3,"sources":["src/types&declarations.ts","src/utils.ts","src/tetrisBoard.ts","src/tile.ts","src/currentPiece.ts","src/inputHandler.ts","src/piecesController.ts","src/index.ts"],"names":[],"mappings":"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","file":"src.116e6fae.js","sourceRoot":"..","sourcesContent":["import { Tile } from \"./tile\";\r\n\r\n// board coordinates type definition\r\nexport type gridCord = {\r\n  x: number;\r\n  y: number;\r\n  filled: boolean;\r\n  squareColor: string\r\n};\r\n//a single piece\r\ntype Piece = {\r\n  kind: 'piece',\r\n  pieceCords: Array<number[]>\r\n}\r\n//set of pieces\r\ntype PieceCollection = {\r\n  kind: 'pieceCollection',\r\n  pieceCords: Array<number[][]>\r\n}\r\n//wrapper containing all the pieces\r\nexport type PiecesWrapper = {\r\n  [piece_name: string]: PieceCollection | Piece\r\n}\r\n//possible offset cases of each tetris\r\nexport type PiecesOffsets = {\r\n  [piece_name: string]: Array<number[][]>\r\n}\r\n//tetris piece's letter to extract the relevant piece's set of offsets\r\nexport enum PieceOffset {\r\n  JLSTZ = \"JLSTZ\",\r\n  I = \"I\",\r\n  O = \"O\"\r\n}\r\nexport const CLOCK_MATRICES = {\r\n  CLOCKWISE: {x1: 0, x2: -1, y1: 1, y2: 0},\r\n  COUNTER_CLOCKWISE: {x1: 0, x2: 1, y1: -1, y2: 0}\r\n}\r\n// a piece column has either a tile or is empty\r\nexport type PieceColumn = Tile | 0;\r\n// Tetro piece holding a 3x3 dimension of tiles\r\ntype PieceRow = [PieceColumn, PieceColumn, PieceColumn]\r\nexport type PieceOfTiles = [PieceRow, [PieceColumn, Tile, PieceColumn], PieceRow];\r\n//tetromino object properties definition\r\nexport type PIECE_OBJECT = [\r\n  PIECE: number[][],\r\n  OFFSETS: number[][][]\r\n];\r\nexport const canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\r\nexport const subCanvas = document.getElementById(\"subCanvas\") as HTMLCanvasElement\r\nexport const cvsContext = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\nexport const subCanvasCtx = subCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\nexport const scoreEl = document.getElementById(\"score\") as HTMLSpanElement\r\nexport const resetBtn = document.getElementById(\"reset\") as HTMLButtonElement\r\n\r\n// generate 6-digit hexcode color value for each piece\r\ntype HexValues = \"0\"|\"1\"|\"2\"| \"3\"| \"4\"| \"5\"| \"6\"| \"7\"| \"8\"| \"9\"|\"10\"| \"A\"| \"B\"|\"C\"| \"D\"| \"E\"|\"F\"\r\nexport type Hexcode = HexValues[]\r\nexport const setOfHexvalues: Hexcode = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]","import { Game } from \".\";\r\nimport { GRID_COLUMNS, GRID_ROWS } from \"./tetrisBoard\";\r\nimport {Hexcode, gridCord} from \"./types&declarations\"\r\n\r\nexport function randomValue<T>(array: T[]): T {\r\n  return array[Math.floor(Math.random() * array.length)];\r\n}\r\n// dispalay game over text\r\nfunction displayGameover(ctx: CanvasRenderingContext2D){\r\n  ctx.fillStyle = \"#00000080\"\r\n  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\r\n  ctx.font =  \"32px Arial Sans-serif\"\r\n  ctx.textAlign = 'center'\r\n  ctx.fillStyle = \"#000\"\r\n  ctx.fillText(\"Game Over!\", ctx.canvas.width / 2+2, ctx.canvas.height / 2+2)\r\n  ctx.fillStyle = \"#fff\"\r\n  ctx.fillText(\"Game Over!\", ctx.canvas.width / 2, ctx.canvas.height / 2)\r\n}\r\n// animate the tetris game using requesAnimationFrame func\r\nexport function createAnimation(currentGame: Game) {\r\n  let elapsedGameTime = 0;\r\n  function animate(timeStamp: number) {\r\n    const timeElapsed = timeStamp - elapsedGameTime;\r\n    elapsedGameTime = timeStamp;\r\n    currentGame.update(timeElapsed);\r\n    if (!currentGame.gameOver) {\r\n      currentGame.draw();\r\n      currentGame.animationToken = requestAnimationFrame(animate);\r\n    }else displayGameover(currentGame.ctx)\r\n  }\r\n  animate(0);\r\n}\r\n//true modulo operation that works for positive & negative integers\r\nexport function mod(x: number, m: number): number {\r\n  return ((x % m) + m) % m;\r\n}\r\n// generate random string of hex-color code\r\nexport function genHexColorCode(hexcode: Hexcode, len=6, str=\"\"): `#${string}`{\r\n  if (len < 1) return `#${str}`\r\n  const nextHexcode = randomValue(hexcode);\r\n  if (str.indexOf(nextHexcode) === -1){\r\n    str += nextHexcode\r\n    return genHexColorCode(hexcode, --len, str)\r\n  }\r\n  return genHexColorCode(hexcode, len, str)\r\n}\r\n\r\nexport function newBoard():gridCord[][] {\r\n  let board: gridCord[][] = []\r\n  for (let i = 0; i < GRID_ROWS; ++i) {\r\n    board[i] = [];\r\n    for (let j = 0; j < GRID_COLUMNS; ++j) {\r\n      board[i][j] = {\r\n        x: j,\r\n        y: i,\r\n        filled: false,\r\n        squareColor: \"transparent\"\r\n      };\r\n    }\r\n  }\r\n  return board\r\n}","import { gridCord } from \"./types&declarations\";\r\nimport { canvas } from \"./types&declarations\";\r\nimport { newBoard } from \"./utils\";\r\n\r\n//tetris board dimensions\r\nexport const TILE_SIZE = 30;\r\nexport const GRID_COLUMNS = canvas.width / TILE_SIZE;\r\nexport const GRID_ROWS = canvas.height / TILE_SIZE;\r\n\r\nexport class Board {\r\n  map: gridCord[][];\r\n  tileSize: number;\r\n  score = 0;\r\n  blankSpace = 4;\r\n\r\n  constructor(tileSize: number) {\r\n    this.map = newBoard();\r\n    this.tileSize = tileSize;\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D) {\r\n    // draw map bg color\r\n    ctx.fillStyle = \"#bca0dc\";\r\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    //white space separator between tiles\r\n    ctx.fillStyle = \"#fff\";\r\n    for (let i = 0; i <= this.map[0].length; ++i) {\r\n      const x =\r\n        i * this.tileSize - this.blankSpace >= 0\r\n          ? i * this.tileSize - this.blankSpace\r\n          : 0;\r\n      ctx.fillRect(x, 0, this.blankSpace, ctx.canvas.height);\r\n    }\r\n    for (let j = 0; j <= this.map.length; ++j) {\r\n      const y =\r\n        j * this.tileSize - this.blankSpace >= 0\r\n          ? j * this.tileSize - this.blankSpace\r\n          : 0;\r\n      ctx.fillRect(0, y, ctx.canvas.width, this.blankSpace);\r\n    }\r\n\r\n    this.map.forEach((row) => {\r\n      row.forEach((column) => {\r\n        if (column.filled) {\r\n          ctx.fillStyle = column.squareColor;\r\n          ctx.fillRect(\r\n            column.x * this.tileSize,\r\n            column.y * this.tileSize,\r\n            this.tileSize,\r\n            this.tileSize\r\n          );\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  removeBoardRow() {\r\n    for (let i = 0; i < this.map.length; ++i) {\r\n      let isFilled = true;\r\n      for (let j: number = 0; j < this.map[i].length; ++j) {\r\n        if (!this.map[i][j].filled) {\r\n          isFilled = false;\r\n        }\r\n      }\r\n      if (isFilled) {\r\n        this.score += 2;\r\n        for (let k = i; k > 0; --k) {\r\n          for (let l = 0; l < this.map[k].length; ++l) {\r\n            this.map[k][l].filled = this.map[k - 1][l].filled;\r\n            this.map[k][l].squareColor = this.map[k - 1][l].squareColor;\r\n          }\r\n        }\r\n        for (let i = 0; i < GRID_COLUMNS; ++i) {\r\n          this.map[0][i] = {\r\n            x: i,\r\n            y: GRID_ROWS - 1,\r\n            filled: false,\r\n            squareColor: \"transparent\"\r\n          };\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { gridCord, CLOCK_MATRICES } from \"./types&declarations\";\r\nimport { GRID_COLUMNS, GRID_ROWS } from \"./tetrisBoard\";\r\n\r\nexport class Tile {\r\n  x: number;\r\n  y: number;\r\n  board: gridCord[][];\r\n\r\n  moveToRight(x: number = 1) {\r\n    this.x += x;\r\n  }\r\n  moveToleft(x: number = -1) {\r\n    this.x += x;\r\n  }\r\n  moveToBottom(y: number = 1) {\r\n    this.y += y;\r\n  }\r\n  moveToTop(y: number = 1) {\r\n    this.y -= y;\r\n  }\r\n  moveRight(x: number) {\r\n    return this.x + x < GRID_COLUMNS;\r\n  }\r\n  moveLeft(x: number) {\r\n    return this.x + x >= 0;\r\n  }\r\n  moveDown(y: number) {\r\n    return this.y + y < GRID_ROWS;\r\n  }\r\n  moveUp(y: number) {\r\n    return this.y + y >= 0;\r\n  }\r\n  isTopMostPos() {\r\n    return this.y < 0;\r\n  }\r\n\r\n  checkBottomTile(y: number) {\r\n    return (\r\n      this.isTopMostPos() ||\r\n      (this.moveDown(y) && !this.board[this.y + y][this.x].filled)\r\n    );\r\n  }\r\n  checkTopTile(y: number) {\r\n    return this.moveUp(-y) && !this.board[this.y - y][this.x].filled;\r\n  }\r\n  checkRightTile(x: number) {\r\n    return (\r\n      (this.isTopMostPos() && this.moveRight(x)) ||\r\n      (this.moveRight(x) && !this.board[this.y][this.x + x].filled)\r\n    );\r\n  }\r\n  checkLeftTile(x: number) {\r\n    return (\r\n      (this.isTopMostPos() && this.moveLeft(x)) ||\r\n      (this.moveLeft(x) && !this.board[this.y][this.x + x].filled)\r\n    );\r\n  }\r\n\r\n  checkBottomRightTile(x: number, y: number) {\r\n    return (\r\n      this.isTopMostPos() ||\r\n      (this.moveDown(-y) &&\r\n        this.moveRight(x) &&\r\n        !this.board[this.y - y][this.x + x].filled)\r\n    );\r\n  }\r\n  checkBottomLeftTile(x: number, y: number) {\r\n    return (\r\n      this.isTopMostPos() ||\r\n      (this.moveDown(-y) &&\r\n        this.moveLeft(x) &&\r\n        !this.board[this.y - y][this.x + x].filled)\r\n    );\r\n  }\r\n  checkTopRightTile(x: number, y: number) {\r\n    return (\r\n      this.moveUp(-y) &&\r\n      this.moveRight(x) &&\r\n      !this.board[this.y - y][this.x + x].filled\r\n    );\r\n  }\r\n  checkTopLeftTile(x: number, y: number) {\r\n    return (\r\n      this.moveUp(-y) &&\r\n      this.moveLeft(x) &&\r\n      !this.board[this.y - y][this.x + x].filled\r\n    );\r\n  }\r\n  checkPureRot() {\r\n    return (\r\n      this.moveRight(0) &&\r\n      this.moveLeft(0) &&\r\n      this.moveDown(0) &&\r\n      this.moveUp(0) &&\r\n      !this.board[this.y][this.x].filled\r\n    );\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D, sizeOfTile: number): void {\r\n    ctx.fillRect(\r\n      this.x * sizeOfTile,\r\n      this.y * sizeOfTile,\r\n      sizeOfTile,\r\n      sizeOfTile\r\n    );\r\n  }\r\n  rotateTile(centerTile: Tile, isClockwise: boolean): void {\r\n    const RELATIVE_POSITION = {\r\n      x: this.x - centerTile.x,\r\n      y: this.y - centerTile.y\r\n    };\r\n\r\n    const rotMatrix = {\r\n      x1: isClockwise\r\n        ? CLOCK_MATRICES.CLOCKWISE.x1\r\n        : CLOCK_MATRICES.COUNTER_CLOCKWISE.x1,\r\n      x2: isClockwise\r\n        ? CLOCK_MATRICES.CLOCKWISE.x2\r\n        : CLOCK_MATRICES.COUNTER_CLOCKWISE.x2,\r\n      y1: isClockwise\r\n        ? CLOCK_MATRICES.CLOCKWISE.y1\r\n        : CLOCK_MATRICES.COUNTER_CLOCKWISE.y1,\r\n      y2: isClockwise\r\n        ? CLOCK_MATRICES.CLOCKWISE.y2\r\n        : CLOCK_MATRICES.COUNTER_CLOCKWISE.y2\r\n    };\r\n\r\n    const rotationCord = {\r\n      x:\r\n        rotMatrix.x1 * RELATIVE_POSITION.x + rotMatrix.x2 * RELATIVE_POSITION.y,\r\n      y: rotMatrix.y1 * RELATIVE_POSITION.x + rotMatrix.y2 * RELATIVE_POSITION.y\r\n    };\r\n\r\n    this.x = rotationCord.x + centerTile.x;\r\n    this.y = rotationCord.y + centerTile.y;\r\n  }\r\n  constructor(x: number, y: number, board: gridCord[][]) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.board = board;\r\n  }\r\n}\r\n","import {GRID_COLUMNS } from \"./tetrisBoard\";\r\nimport { Tile } from \"./tile\";\r\nimport {\r\n  PieceOfTiles,\r\n  gridCord,\r\n  PIECE_OBJECT,\r\n} from \"./types&declarations\";\r\nimport { mod } from \"./utils\";\r\n\r\nexport class Piece {\r\n  currentPiece: number[][];\r\n  offsets: number[][][];\r\n  tetrominoes: PieceOfTiles;\r\n  centerPiece: Tile;\r\n  rotationIndex: number;\r\n  board: gridCord[][];\r\n  color: `#${string}`\r\n\r\n  constructor(\r\n    currentPiece: number[][],\r\n    offsets: number[][][],\r\n    board: gridCord[][],\r\n    rotationIndex: number,\r\n    color: `#${string}`\r\n  ) {\r\n    this.board = board;\r\n    this.currentPiece = currentPiece;\r\n    this.offsets = offsets;\r\n    this.tetrominoes = this.initMinos();\r\n    this.centerPiece = this.tetrominoes[1][1];\r\n    this.rotationIndex = rotationIndex;\r\n    this.color = color\r\n  }\r\n\r\n  initMinos(): PieceOfTiles {\r\n    return this.currentPiece.map((row, rowIndex) => {\r\n      return row.map((column, colIndex) => {\r\n        if (column) {\r\n          return new Tile(\r\n            Math.floor(GRID_COLUMNS / 2) + colIndex - 1,\r\n            rowIndex - 3,\r\n            this.board\r\n          );\r\n        }\r\n        return 0;\r\n      });\r\n    }) as PieceOfTiles;\r\n  }\r\n\r\n  checkBottom(): boolean {\r\n    let isMovable = true;\r\n    for (let i = 0; i < this.tetrominoes.length; ++i) {\r\n      for (let j = 0; j < this.tetrominoes[i].length; ++j) {\r\n        if (this.tetrominoes[i][j] === 0) continue;\r\n        if (!(this.tetrominoes[i][j] as Tile).checkBottomTile(1)) {\r\n          isMovable = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return isMovable;\r\n  }\r\n\r\n  checkRight(): boolean {\r\n    for (let i = 0; i < this.tetrominoes.length; ++i) {\r\n      for (let j = 0; j < this.tetrominoes[i].length; ++j) {\r\n        if (this.tetrominoes[i][j] === 0) continue;\r\n        if (!(this.tetrominoes[i][j] as Tile).checkRightTile(1)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  checkLeft(): boolean {\r\n    for (let i = 0; i < this.tetrominoes.length; ++i) {\r\n      for (let j = 0; j < this.tetrominoes[i].length; ++j) {\r\n        if (this.tetrominoes[i][j] === 0) continue;\r\n        if (!(this.tetrominoes[i][j] as Tile).checkLeftTile(-1)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  checkGameover(): boolean {\r\n    const boardTop = this.board[0]\r\n    for(let i=0; i < boardTop.length; ++i){\r\n      if (boardTop[i].filled){\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  dropPiece(isMoveable: boolean) {\r\n    if (!isMoveable){\r\n      for(let i=0; i < this.tetrominoes.length; ++i){\r\n        for(let j=0; j < this.tetrominoes[i].length; ++j){\r\n          if (this.tetrominoes[i][j] === 0) continue;\r\n          const {x, y} = (this.tetrominoes[i][j] as Tile)\r\n          if (y >= 0) {\r\n            this.board[y][x].filled = true\r\n            this.board[y][x].squareColor = this.color          \r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  playNextPiece(nextPiece: PIECE_OBJECT): void {\r\n    this.currentPiece = nextPiece[0];\r\n    this.offsets = nextPiece[1];\r\n    this.tetrominoes = this.initMinos();\r\n    this.centerPiece = this.tetrominoes[1][1];\r\n    this.rotationIndex = 0;\r\n  }\r\n\r\n  rotatePiece(isClockWise: boolean, willOffset: boolean): void {\r\n    const oldRotIndex = this.rotationIndex;\r\n    this.rotationIndex += isClockWise ? 1 : -1;\r\n    this.rotationIndex = mod(this.rotationIndex, 4);\r\n    this.tetrominoes.forEach((row) => {\r\n      row.forEach((column) => {\r\n        if (column && column !== this.centerPiece) {\r\n          column.rotateTile(this.centerPiece, isClockWise);\r\n        }\r\n      });\r\n    });\r\n    if (!willOffset) {\r\n      return;\r\n    }\r\n    const canOffset = this.shouldOffset(oldRotIndex, this.rotationIndex);\r\n\r\n    if (!canOffset) {\r\n      this.rotatePiece(!isClockWise, false);\r\n      return;\r\n    }\r\n  }\r\n\r\n  shouldOffset(origIndex: number, newindex: number): boolean {\r\n    let shouldMove = false;\r\n    let endOffset: number[] = [];\r\n    for (let testIndex = 0; testIndex < this.offsets.length; ++testIndex) {\r\n      const offsetVal1 = this.offsets[testIndex][origIndex];\r\n      const offsetVal2 = this.offsets[testIndex][newindex];\r\n      endOffset[0] = offsetVal1[0] - offsetVal2[0];\r\n      endOffset[1] = offsetVal1[1] - offsetVal2[1];\r\n      if (this.canOffset(endOffset)) {\r\n        shouldMove = true;\r\n        break;\r\n      }\r\n    }\r\n    if (shouldMove) this.offsetMove(endOffset);\r\n    return shouldMove;\r\n  }\r\n\r\n  canOffset(offsetCord: number[]): boolean {\r\n    return this.tetrominoes.every((row) => {\r\n      return row.every((column) => {\r\n        if (column) {\r\n          if (\r\n            offsetCord[0] === 0 &&\r\n            offsetCord[1] === 0 &&\r\n            column.checkPureRot()\r\n          )\r\n            return true;\r\n\r\n          if (\r\n            offsetCord[0] > 0 &&\r\n            offsetCord[1] > 0 &&\r\n            column.checkTopRightTile(offsetCord[0], offsetCord[1])\r\n          )\r\n            return true;\r\n          if (\r\n            offsetCord[0] < 0 &&\r\n            offsetCord[1] < 0 &&\r\n            column.checkBottomLeftTile(offsetCord[0], offsetCord[1])\r\n          )\r\n            return true;\r\n          if (\r\n            offsetCord[0] === 0 &&\r\n            offsetCord[1] < 0 &&\r\n            column.moveLeft(0) &&\r\n            column.moveRight(0) &&\r\n            column.checkBottomTile(-offsetCord[1])\r\n          )\r\n            return true;\r\n          if (\r\n            offsetCord[1] === 0 &&\r\n            offsetCord[0] < 0 &&\r\n            column.moveUp(0) &&\r\n            column.moveDown(0) &&\r\n            column.checkLeftTile(offsetCord[0])\r\n          )\r\n            return true;\r\n\r\n          if (\r\n            offsetCord[0] > 0 &&\r\n            offsetCord[1] === 0 &&\r\n            column.moveUp(0) &&\r\n            column.moveDown(0) &&\r\n            column.checkRightTile(offsetCord[0])\r\n          )\r\n            return true;\r\n\r\n          if (\r\n            offsetCord[0] === 0 &&\r\n            offsetCord[1] > 0 &&\r\n            column.moveRight(0) &&\r\n            column.moveLeft(0) &&\r\n            column.checkTopTile(offsetCord[1])\r\n          )\r\n            return true;\r\n\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n    });\r\n  }\r\n\r\n  offsetMove(offsetCord: number[]) {\r\n    this.tetrominoes.forEach((row) => {\r\n      row.forEach((column) => {\r\n        if (column) {\r\n          const [x, y] = [...offsetCord];\r\n          if (x < 0) column.moveToleft(x);\r\n          else if (x >= 0) column.moveToRight(x);\r\n          if (y < 0) column.moveToBottom(-y);\r\n          else if (y >= 0) column.moveToTop(y);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}","import { Game } from \"./index\";\r\n\r\nexport class Input {\r\n  constructor(game: Game) {\r\n    window.addEventListener(\"keydown\", (e) => {\r\n      switch (e.key) {\r\n        case \"ArrowRight\":\r\n        case \"ArrowLeft\":\r\n        case \"ArrowDown\":\r\n        case \"x\":\r\n        case \"s\":\r\n          if (!game.playerinput.includes(e.key)) game.playerinput.push(e.key);\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n    });\r\n    window.addEventListener(\"keyup\", (e) => {\r\n      switch (e.key) {\r\n        case \"ArrowRight\":\r\n        case \"ArrowLeft\":\r\n        case \"ArrowDown\":\r\n        case \"x\":\r\n        case \"s\":\r\n          if (game.playerinput.includes(e.key))\r\n            game.playerinput.splice(game.playerinput.indexOf(e.key), 1);\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n    });\r\n  }\r\n}\r\n","import {\r\n  PIECE_OBJECT,\r\n  PieceOffset,\r\n  PiecesOffsets,\r\n  PiecesWrapper\r\n} from \"./types&declarations\";\r\nimport { randomValue } from \"./utils\";\r\n\r\nexport const OFFSETS: PiecesOffsets = {\r\n  JLSTZ: [\r\n    [\r\n      [0, 0],\r\n      [0, 0],\r\n      [0, 0],\r\n      [0, 0]\r\n    ],\r\n    [\r\n      [0, 0],\r\n      [1, 0],\r\n      [0, 0],\r\n      [-1, 0]\r\n    ],\r\n    [\r\n      [0, 0],\r\n      [1, -1],\r\n      [0, 0],\r\n      [-1, -1]\r\n    ],\r\n    [\r\n      [0, 0],\r\n      [0, 2],\r\n      [0, 0],\r\n      [0, 2]\r\n    ],\r\n    [\r\n      [0, 0],\r\n      [1, 2],\r\n      [0, 0],\r\n      [-1, 2]\r\n    ]\r\n  ],\r\n  I: [\r\n    [\r\n      [0, 0],\r\n      [-1, 0],\r\n      [-1, 1],\r\n      [0, 1]\r\n    ],\r\n    [\r\n      [-1, 0],\r\n      [0, 0],\r\n      [1, 1],\r\n      [0, 1]\r\n    ],\r\n    [\r\n      [2, 0],\r\n      [0, 0],\r\n      [-2, 1],\r\n      [0, 1]\r\n    ],\r\n    [\r\n      [-1, 0],\r\n      [0, 1],\r\n      [1, 0],\r\n      [0, -1]\r\n    ],\r\n    [\r\n      [2, 0],\r\n      [0, -2],\r\n      [-2, 0],\r\n      [0, 2]\r\n    ]\r\n  ],\r\n  O: [\r\n    [\r\n      [0, 0],\r\n      [0, -1],\r\n      [-1, -1],\r\n      [-1, 0]\r\n    ]\r\n  ]\r\n};\r\n\r\nexport const PIECES: PiecesWrapper = {\r\n  JLSTZ: {\r\n    pieceCords: [\r\n      [\r\n        [1, 0, 0],\r\n        [1, 1, 1],\r\n        [0, 0, 0]\r\n      ],\r\n      [\r\n        [0, 0, 1],\r\n        [1, 1, 1],\r\n        [0, 0, 0]\r\n      ],\r\n      [\r\n        [0, 1, 1],\r\n        [1, 1, 0],\r\n        [0, 0, 0]\r\n      ],\r\n      [\r\n        [0, 1, 0],\r\n        [1, 1, 1],\r\n        [0, 0, 0]\r\n      ],\r\n      [\r\n        [1, 1, 0],\r\n        [0, 1, 1],\r\n        [0, 0, 0]\r\n      ]\r\n    ],\r\n    kind: \"pieceCollection\"\r\n  },\r\n  O: {\r\n    pieceCords: [\r\n      [0, 1, 1],\r\n      [0, 1, 1],\r\n      [0, 0, 0]\r\n    ],\r\n    kind: \"piece\"\r\n  },\r\n  I: {\r\n    pieceCords: [\r\n      [0, 0, 0],\r\n      [1, 1, 1],\r\n      [0, 0, 0]\r\n    ],\r\n    kind: \"piece\"\r\n  }\r\n};\r\n\r\nexport function initiatePiece(): PIECE_OBJECT {\r\n  const chosenPieceLetter = randomValue(Object.keys(PieceOffset));\r\n  const pieceOffsets = OFFSETS[chosenPieceLetter];\r\n  let chosenPiece = PIECES[chosenPieceLetter];\r\n\r\n  if (chosenPiece.kind === \"pieceCollection\") {\r\n    return [randomValue(chosenPiece.pieceCords), pieceOffsets];\r\n  }\r\n  return [chosenPiece.pieceCords, pieceOffsets];\r\n}\r\n","import {\n  cvsContext,\n  subCanvasCtx,\n  canvas,\n  PIECE_OBJECT,\n  setOfHexvalues,\n  scoreEl,\n  resetBtn\n} from \"./types&declarations\";\nimport { Board, TILE_SIZE } from \"./tetrisBoard\";\nimport { Piece } from \"./currentPiece\";\nimport { Input } from \"./inputHandler\";\nimport { createAnimation, genHexColorCode, newBoard } from \"./utils\";\nimport { initiatePiece } from \"./piecesController\";\n\nexport class Game {\n  ctx: CanvasRenderingContext2D;\n  subCvsCtx: CanvasRenderingContext2D;\n  board: Board;\n  piece: Piece;\n  nextPiece: PIECE_OBJECT;\n  inputClass: Input;\n  playerinput: string[] = [];\n  gameSpeedPerMiliSec: number;\n  gameTimeInterval: number;\n  miliSecPerFrames: number;\n  frameTimeInterval: number;\n  scoreElement = scoreEl;\n  gameOver: boolean;\n  animationToken = 0;\n\n  update(timePassed: number): void {\n    this.gameTimeInterval += timePassed;\n    this.frameTimeInterval += timePassed;\n\n    if (this.gameTimeInterval >= this.gameSpeedPerMiliSec) {\n      //rotating clockwise or counter-clockwise based on the key pressed\n      if (this.playerinput.includes(\"s\")) this.piece.rotatePiece(true, true);\n      if (this.playerinput.includes(\"x\")) this.piece.rotatePiece(false, true);\n\n      // keep the piece dropping or fix it on floor\n      const pieceIsMoving = this.piece.checkBottom();\n      if (pieceIsMoving) {\n        this.piece.tetrominoes.forEach((row) => {\n          row.forEach((column) => {\n            if (column) {\n              column.moveToBottom();\n            }\n          });\n        });\n      } else {\n        this.piece.dropPiece(pieceIsMoving);\n        this.board.removeBoardRow();\n        this.scoreElement.textContent = this.board.score.toString();\n        this.piece = new Piece(\n          ...this.nextPiece,\n          this.board.map,\n          0,\n          genHexColorCode(setOfHexvalues)\n        );\n        this.nextPiece = initiatePiece();\n      }\n      this.gameOver = this.piece.checkGameover();\n      this.gameTimeInterval = 0;\n    }\n    if (this.frameTimeInterval >= this.miliSecPerFrames) {\n      if (this.playerinput.includes(\"ArrowRight\") && this.piece.checkRight()) {\n        this.piece.tetrominoes.forEach((row) => {\n          row.forEach((column) => {\n            if (column) column.moveToRight();\n          });\n        });\n      }\n      if (this.playerinput.includes(\"ArrowLeft\") && this.piece.checkLeft()) {\n        this.piece.tetrominoes.forEach((row) => {\n          row.forEach((column) => {\n            if (column) column.moveToleft();\n          });\n        });\n      }\n      if (this.playerinput.includes(\"ArrowDown\") && this.piece.checkBottom()) {\n        this.piece.tetrominoes.forEach((row) => {\n          row.forEach((column) => {\n            if (column) column.moveToBottom();\n          });\n        });\n      }\n      this.frameTimeInterval = 0;\n    }\n  }\n\n  draw(): void {\n    this.ctx.clearRect(0, 0, canvas.width, canvas.height);\n    //draw fixed squares on board\n    this.board.draw(this.ctx);\n    //draw current piece\n    this.piece.tetrominoes.forEach((row) => {\n      row.forEach((column) => {\n        if (column) {\n          this.ctx.fillStyle = this.piece.color;\n          column.draw(this.ctx, this.board.tileSize);\n        }\n      });\n    });\n    this.drawNextPiece();\n  }\n\n  drawNextPiece() {\n    this.subCvsCtx.clearRect(\n      0,\n      0,\n      subCanvasCtx.canvas.width,\n      subCanvasCtx.canvas.height\n    );\n    this.subCvsCtx.fillStyle = \"#ef709b\";\n    this.subCvsCtx.fillRect(\n      0,\n      0,\n      this.subCvsCtx.canvas.width,\n      this.subCvsCtx.canvas.height\n    );\n    this.subCvsCtx.fillStyle = \"#000\";\n    this.nextPiece[0].forEach((row, rowIndex) => {\n      row.forEach((column, colIndex) => {\n        if (column) {\n          this.subCvsCtx.fillRect(\n            20 * (colIndex + 1),\n            20 * (rowIndex + 1),\n            20,\n            20\n          );\n        }\n      });\n    });\n  }\n  constructor(\n    ctx: CanvasRenderingContext2D,\n    subCvsCtx: CanvasRenderingContext2D,\n    board: Board,\n    tileSize: number\n  ) {\n    this.ctx = ctx;\n    this.subCvsCtx = subCvsCtx;\n    this.board = board;\n    this.piece = new Piece(\n      ...initiatePiece(),\n      this.board.map,\n      0,\n      genHexColorCode(setOfHexvalues)\n    );\n    this.nextPiece = initiatePiece();\n    this.inputClass = new Input(this);\n    this.gameSpeedPerMiliSec = 1000 / 5;\n    this.miliSecPerFrames = 2000 / 16.67;\n    this.gameTimeInterval = 0;\n    this.frameTimeInterval = 0;\n    this.gameOver = false;\n  }\n}\nlet newGame = new Game(\n  cvsContext,\n  subCanvasCtx,\n  new Board(TILE_SIZE),\n  TILE_SIZE\n);\ncreateAnimation(newGame);\n\nresetBtn.addEventListener(\"click\", () => {\n  cancelAnimationFrame(newGame.animationToken);\n  scoreEl.textContent = \"0\";\n  newGame = new Game(cvsContext, subCanvasCtx, new Board(TILE_SIZE), TILE_SIZE);\n  createAnimation(newGame);\n});\n"]}